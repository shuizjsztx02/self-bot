# 多智能体记忆复用重构方案（完整版）

## 一、当前架构问题分析

### 1.1 现有架构图

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              当前架构（存在问题）                                     │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  AgentManager.get_agent(conversation_id)                                            │
│      │                                                                              │
│      ▼                                                                              │
│  SupervisorAgent.__init__()                                                         │
│      │                                                                              │
│      ├──► MainAgent.__init__()                                                      │
│      │        │                                                                     │
│      │        └──► ShortTermMemory()  ◄─── 独立实例                                 │
│      │              ├── messages[] = []                                             │
│      │              └── summaries[] = []                                            │
│      │                                                                              │
│      ├──► RagAgent.__init__()                                                       │
│      │        │                                                                     │
│      │        └──► ContextManager()  ◄─── 另一个独立实例（问题所在！）               │
│      │              ├── _history[] = []  ← 永远为空！                               │
│      │              └── _entity_cache[] = []                                        │
│      │                                                                              │
│      └──► ResearcherAgent.__init__()                                                │
│               │                                                                     │
│               └──► 无记忆模块  ◄─── 完全没有对话历史！                              │
│                                                                                     │
│  问题：                                                                             │
│  1. MainAgent.ShortTermMemory 和 RagAgent.ContextManager 是两个独立的实例          │
│  2. ResearcherAgent 没有任何记忆模块，无法获取对话上下文                            │
│  3. AgentManager.load_history() 只加载到 MainAgent.ShortTermMemory                 │
│  4. RagAgent.ContextManager 从未被填充数据，永远为空                               │
│  5. 查询重写时获取历史为空，无法正确重写代词                                        │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 数据流问题

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              数据流分析                                              │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  [请求进入] POST /api/chat/stream                                                   │
│      │                                                                              │
│      ▼                                                                              │
│  AgentManager.get_agent(conversation_id)                                            │
│      │                                                                              │
│      ├── 缓存命中？                                                                 │
│      │       ├── 是 → agent.main_agent.short_term_memory.clear()                   │
│      │       │       └── load_history() → 加载到 MainAgent.ShortTermMemory         │
│      │       └── 否 → 创建新 Agent                                                  │
│      │                                                                              │
│      ▼                                                                              │
│  SupervisorAgent.chat(message)                                                      │
│      │                                                                              │
│      ├── 意图分类 → 路由决策                                                        │
│      │                                                                              │
│      ├── 路由: "rag_first"                                                          │
│      │       └── RagAgent.process_query()                                           │
│      │               └── history = [] ← 空的！无法重写代词                          │
│      │                                                                              │
│      ├── 路由: "research_first"                                                     │
│      │       └── ResearcherAgent.research(topic)                                    │
│      │               └── 无历史上下文，不知道用户之前讨论了什么                      │
│      │                                                                              │
│      └── 路由: "direct"                                                             │
│              └── MainAgent.chat()                                                   │
│                      └── 使用 MainAgent.ShortTermMemory ← 这里有历史数据           │
│                                                                                     │
│  结果：                                                                             │
│  - RAG 查询重写功能失效                                                             │
│  - ResearcherAgent 无上下文，搜索结果可能不相关                                     │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.3 问题总结

| 问题 | 原因 | 影响 |
|------|------|------|
| **ContextManager 永远为空** | RagAgent 每次创建新的 ContextManager 实例 | 查询重写无历史可用 |
| **ResearcherAgent 无记忆** | 没有注入任何记忆模块 | 搜索缺乏上下文 |
| **记忆系统重复** | ShortTermMemory 和 ContextManager 功能重叠 | 代码冗余，维护困难 |
| **数据不共享** | 三个 Agent 各自独立 | 无法利用完整对话历史 |
| **代词解析失效** | 无历史上下文 | "它是什么？" 无法正确解析 |

---

## 二、重构方案

### 2.1 目标架构

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              重构后架构                                              │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  AgentManager.get_agent(conversation_id)                                            │
│      │                                                                              │
│      ▼                                                                              │
│  SupervisorAgent.__init__()                                                         │
│      │                                                                              │
│      ├──► shared_memory = ShortTermMemory()  ◄─── 共享实例（核心改动）              │
│      │        ├── messages[]                                                        │
│      │        └── summaries[]                                                       │
│      │                                                                              │
│      ├──► MainAgent(short_term_memory=shared_memory)  ◄─── 注入共享记忆             │
│      │                                                                              │
│      ├──► RagAgent(short_term_memory=shared_memory)   ◄─── 注入共享记忆             │
│      │        │                                                                     │
│      │        └── 删除 ContextManager，直接使用 shared_memory                      │
│      │                                                                              │
│      └──► ResearcherAgent(short_term_memory=shared_memory)  ◄─── 注入共享记忆       │
│               │                                                                     │
│               └── 新增记忆模块，可获取对话历史                                      │
│                                                                                     │
│  优点：                                                                             │
│  1. MainAgent、RagAgent、ResearcherAgent 共享同一个记忆实例                         │
│  2. AgentManager.load_history() 加载的数据对所有 Agent 可见                        │
│  3. RAG 查询重写可以正确获取历史                                                    │
│  4. ResearcherAgent 可以基于上下文进行更精准的搜索                                  │
│  5. 删除冗余的 ContextManager 代码                                                  │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 重构后数据流

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              重构后数据流                                            │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  [请求进入] POST /api/chat/stream                                                   │
│      │                                                                              │
│      ▼                                                                              │
│  AgentManager.get_agent(conversation_id)                                            │
│      │                                                                              │
│      ├── 缓存命中？                                                                 │
│      │       └── 是 → shared_memory.clear() + load_history()                       │
│      │               └── 加载到共享的 ShortTermMemory                               │
│      │                                                                              │
│      ▼                                                                              │
│  SupervisorAgent.chat(message)                                                      │
│      │                                                                              │
│      ├── 路由: "rag_first"                                                          │
│      │       └── RagAgent.process_query()                                           │
│      │               ├── history = shared_memory.get_history_as_turns()            │
│      │               └── query_rewriter.rewrite(query, history) ✅ 有数据          │
│      │                                                                              │
│      ├── 路由: "research_first"                                                     │
│      │       └── ResearcherAgent.research_with_context()                            │
│      │               ├── context = shared_memory.get_context()                     │
│      │               └── 基于上下文生成更精准的搜索查询 ✅                          │
│      │                                                                              │
│      └── 路由: "direct"                                                             │
│              └── MainAgent.chat()                                                   │
│                      └── 使用 shared_memory ✅ 同一数据                             │
│                                                                                     │
│  结果：                                                                             │
│  - RAG 查询重写正常工作，可以正确解析代词                                           │
│  - ResearcherAgent 可以基于对话历史进行更精准的搜索                                 │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、具体代码修改

### 3.1 修改 ShortTermMemory - 添加转换方法

**文件**: `backend/app/langchain/memory/short_term.py`

```python
# 新增方法：转换为 ConversationTurn 列表（供 RAG 使用）
def get_history_as_turns(self, limit: Optional[int] = None) -> List["ConversationTurn"]:
    """
    获取对话历史，转换为 ConversationTurn 格式
    
    供 RAG 模块的 QueryRewriter 使用
    """
    from app.langchain.services.rag.rag_types import ConversationTurn
    
    messages = self.get_context()
    turns = []
    
    for msg in messages:
        if isinstance(msg, HumanMessage):
            turns.append(ConversationTurn(
                role="user",
                content=msg.content,
            ))
        elif isinstance(msg, AIMessage):
            turns.append(ConversationTurn(
                role="assistant",
                content=msg.content,
            ))
    
    if limit:
        turns = turns[-limit:]
    
    return turns

# 新增方法：获取对话摘要文本（供 ResearcherAgent 使用）
def get_context_summary(self, max_tokens: int = 500) -> str:
    """
    获取对话历史的文本摘要
    
    供 ResearcherAgent 生成搜索上下文
    """
    messages = self.get_context(max_tokens=max_tokens)
    
    if not messages:
        return ""
    
    context_parts = []
    for msg in messages:
        if isinstance(msg, HumanMessage):
            context_parts.append(f"用户: {msg.content}")
        elif isinstance(msg, AIMessage):
            # AI 消息截断，避免过长
            content = msg.content[:200] + "..." if len(msg.content) > 200 else msg.content
            context_parts.append(f"助手: {content}")
    
    return "\n".join(context_parts)
```

### 3.2 修改 MainAgent - 支持外部注入 memory

**文件**: `backend/app/langchain/agents/main_agent.py`

```python
class MainAgent:
    def __init__(
        self,
        provider: Optional[str] = None,
        model: Optional[str] = None,
        conversation_id: Optional[str] = None,
        db_session=None,
        short_term_memory=None,  # 新增：支持外部注入
    ):
        # ... 其他初始化 ...
        
        # 如果外部注入了 memory，使用外部的；否则创建新的
        if short_term_memory is not None:
            self.short_term_memory = short_term_memory
        else:
            self.short_term_memory = ShortTermMemory(
                max_tokens=settings.MEMORY_MAX_TOKENS,
                summary_threshold=settings.MEMORY_SUMMARY_THRESHOLD,
                keep_recent_messages=settings.MEMORY_KEEP_RECENT,
            )
```

### 3.3 修改 RagAgent - 使用外部 memory

**文件**: `backend/app/langchain/agents/rag_agent.py`

```python
class RagAgent:
    def __init__(
        self,
        llm: Optional[ChatOpenAI] = None,
        user_id: Optional[str] = None,
        db_session=None,
        config: Optional[RagAgentConfig] = None,
        short_term_memory=None,  # 新增：接收外部 memory
    ):
        self._llm = llm
        self.user_id = user_id
        self.db_session = db_session
        self.config = config or RagAgentConfig()
        
        # 使用外部注入的 memory
        self._short_term_memory = short_term_memory
        
        # 删除 self._context_manager
        self._search_service = None
        self._permission_service = None
        self._kb_service = None
        self._query_rewriter = None
        self._context_compressor = None
    
    async def _get_services(self):
        """懒加载服务"""
        if self._search_service is None:
            # ... 加载 search_service, permission_service, kb_service ...
            
            # 删除 ContextManager 创建
            
            self._query_rewriter = QueryRewriter(
                config=QueryRewriteConfig(
                    max_history_turns=self.config.max_history_turns,
                    enable_query_expansion=self.config.enable_query_expansion,
                ),
                llm_client=self._llm,
            )
            
            # ... 加载 context_compressor ...
    
    async def process_query(self, query: str, kb_ids=None, top_k=5):
        """查询处理"""
        await self._get_services()
        
        # 从共享 memory 获取历史
        if self._short_term_memory:
            history = self._short_term_memory.get_history_as_turns(
                limit=self.config.max_history_turns
            )
        else:
            history = []
        
        # 查询重写（现在有历史数据了）
        if self.config.enable_query_rewrite:
            rewrite_result = await self._query_rewriter.rewrite(query, history)
        else:
            rewrite_result = RewrittenQuery(original_query=query, rewritten_query=query)
        
        # ... 后续处理 ...
    
    def add_assistant_message(self, content: str):
        """添加助手消息到共享 memory"""
        if self._short_term_memory:
            self._short_term_memory.add_short_term_memory(AIMessage(content=content))
```

### 3.4 修改 ResearcherAgent - 支持记忆注入

**文件**: `backend/app/langchain/agents/researcher_agent.py`

```python
class ResearcherAgent:
    """
    研究助手Agent
    
    职责：
    1. 执行互联网搜索
    2. 整合多个来源的信息
    3. 生成研究报告
    
    支持两种调用方式：
    1. 独立执行：通过 research() 方法
    2. 工具模式：通过 as_tool() 方法封装为工具
    """
    
    def __init__(
        self, 
        llm: Optional[ChatOpenAI] = None,
        short_term_memory=None,  # 新增：接收外部 memory
    ):
        self._llm = llm
        self._short_term_memory = short_term_memory  # 新增
        self._tools = [tavily_search, duckduckgo_search, serpapi_search]
        self._tools_by_name = {t.name: t for t in self._tools}
    
    def _get_llm(self) -> ChatOpenAI:
        if self._llm is None:
            self._llm = get_llm()
        return self._llm
    
    @property
    def tools(self) -> list:
        return self._tools
    
    async def research(
        self,
        topic: str,
        max_iterations: Optional[int] = None,
    ) -> str:
        """
        独立执行研究任务（带上下文）
        
        如果有对话历史，会先获取上下文，生成更精准的搜索查询
        """
        max_iterations = max_iterations or settings.RESEARCHER_MAX_ITERATIONS
        llm = self._get_llm()
        
        # 新增：获取对话上下文
        context = ""
        if self._short_term_memory:
            context = self._short_term_memory.get_context_summary(max_tokens=500)
        
        # 构建系统提示
        system_content = """你是研究助手，擅长：
1. 深度搜索：使用多种搜索引擎获取全面信息
2. 信息整合：整合多个来源的信息
3. 报告生成：生成结构化的研究报告

请使用可用的搜索工具完成研究任务，并给出综合性的回答。

注意事项：
- 优先使用 tavily_search，它提供更准确的搜索结果
- 如果一个搜索引擎失败，尝试使用其他搜索引擎
- 整合多个来源的信息，给出全面的回答"""

        # 如果有上下文，添加到系统提示
        if context:
            system_content += f"""

## 对话历史上下文
以下是用户之前的对话历史，请参考这些信息来更好地理解用户的研究需求：

{context}

请基于对话历史上下文来理解用户的研究主题，如果主题中包含代词（如"它"、"这个"等），请根据上下文解析其含义。"""

        messages = [
            SystemMessage(content=system_content),
            HumanMessage(content=topic),
        ]
        
        llm_with_tools = llm.bind_tools(self._tools)
        
        for iteration in range(max_iterations):
            response = await llm_with_tools.ainvoke(messages)
            messages.append(response)
            
            if not response.tool_calls:
                return response.content or "无法获取研究结果"
            
            for tool_call in response.tool_calls:
                tool_name = tool_call["name"]
                tool_args = tool_call["args"]
                tool_id = tool_call.get("id", "")
                
                result = await self._execute_tool(tool_name, tool_args)
                
                messages.append(ToolMessage(
                    content=str(result),
                    tool_call_id=tool_id,
                ))
        
        return "研究超时，请稍后重试"
    
    async def _execute_tool(self, tool_name: str, tool_args: dict) -> str:
        """执行工具调用"""
        tool = self._tools_by_name.get(tool_name)
        if not tool:
            return f"工具 '{tool_name}' 不存在"
        
        try:
            if hasattr(tool, "ainvoke"):
                return await tool.ainvoke(tool_args)
            elif hasattr(tool, "invoke"):
                return tool.invoke(tool_args)
            elif hasattr(tool, "func"):
                import asyncio
                if asyncio.iscoroutinefunction(tool.func):
                    return await tool.func(**tool_args)
                else:
                    return tool.func(**tool_args)
            else:
                return f"工具 '{tool_name}' 无法执行"
        except Exception as e:
            return f"执行 '{tool_name}' 时出错: {str(e)}"
    
    def as_tool(self) -> StructuredTool:
        """
        封装为工具供其他Agent调用
        保持向后兼容
        """
        
        async def run_research(topic: str) -> str:
            return await self.research(topic)
        
        return StructuredTool(
            name="researcher_assistant",
            description="""研究助手：执行深度搜索、信息整合和报告生成任务。

适用场景：
- 需要搜索互联网获取最新信息
- 需要整合多个来源的信息
- 需要生成研究报告

输入应该是研究主题或问题。""",
            args_schema=ResearchInput,
            func=lambda topic: None,
            coroutine=run_research,
        )
```

### 3.5 修改 SupervisorAgent - 创建并注入共享 memory

**文件**: `backend/app/langchain/agents/supervisor_agent.py`

```python
class SupervisorAgent:
    """
    Supervisor Agent
    
    职责：
    1. 接收用户请求
    2. 意图识别与路由决策
    3. 协调多个Agent协作
    4. 支持并行路由
    5. 结果整合与返回
    """
    
    def __init__(
        self,
        provider: Optional[str] = None,
        model: Optional[str] = None,
        user_id: Optional[str] = None,
        conversation_id: Optional[str] = None,
        db_session=None,
    ):
        self.llm = get_llm(provider, model)
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.db_session = db_session
        
        # 核心：创建共享的短期记忆
        from app.langchain.memory import ShortTermMemory
        from app.config import settings
        
        self.shared_memory = ShortTermMemory(
            max_tokens=settings.MEMORY_MAX_TOKENS,
            summary_threshold=settings.MEMORY_SUMMARY_THRESHOLD,
            keep_recent_messages=settings.MEMORY_KEEP_RECENT,
        )
        
        # 注入共享 memory 到 MainAgent
        self.main_agent = MainAgent(
            provider=provider,
            model=model,
            conversation_id=conversation_id,
            short_term_memory=self.shared_memory,  # 注入
        )
        
        # 注入共享 memory 到 RagAgent
        self.rag_agent = RagAgent(
            llm=self.llm,
            user_id=user_id,
            db_session=db_session,
            short_term_memory=self.shared_memory,  # 注入
        )
        
        # 注入共享 memory 到 ResearcherAgent
        self.researcher_agent = ResearcherAgent(
            llm=self.llm,
            short_term_memory=self.shared_memory,  # 注入
        )
        
        self.intent_classifier = IntentClassifier(llm=self.llm, db_session=db_session)
        self.result_selector = ResultSelector(llm=self.llm)
        self._kb_router = None
    
    @property
    def kb_router(self):
        if self._kb_router is None and self.db_session is not None:
            self._kb_router = KBRouter(db=self.db_session)
        return self._kb_router
    
    async def load_history(self, db_session, limit: int = 20) -> int:
        """
        从数据库加载历史消息到共享记忆
        
        Args:
            db_session: 数据库会话
            limit: 最大加载消息数量
            
        Returns:
            加载的消息数量
        """
        from app.langchain.models.database import Message
        from sqlalchemy import select
        from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
        
        result = await db_session.execute(
            select(Message)
            .where(Message.conversation_id == self.conversation_id)
            .order_by(Message.created_at)
            .limit(limit)
        )
        messages = result.scalars().all()
        
        # 加载到共享 memory
        self.shared_memory.clear()
        loaded_count = 0
        for msg in messages:
            if msg.role == "user":
                self.shared_memory.add_short_term_memory(HumanMessage(content=msg.content))
            elif msg.role == "assistant":
                self.shared_memory.add_short_term_memory(AIMessage(content=msg.content))
            loaded_count += 1
        
        return loaded_count
```

### 3.6 修改 AgentManager - 使用新的加载方式

**文件**: `backend/app/langchain/agents/agent_manager.py`

```python
async def get_agent(self, conversation_id, db_session, provider=None, model=None):
    async with self._lock:
        from app.config import settings
        history_limit = getattr(settings, 'HISTORY_LOAD_LIMIT', 20)
        history_enabled = getattr(settings, 'HISTORY_LOAD_ENABLED', True)
        
        if conversation_id in self._active_agents:
            agent = self._active_agents[conversation_id]
            
            if history_enabled:
                try:
                    # 清空共享 memory 并重新加载
                    agent.shared_memory.clear()
                    loaded_count = await agent.load_history(db_session, limit=history_limit)
                    logger.info(f"Reloaded {loaded_count} messages for cached agent: {conversation_id}")
                except Exception as e:
                    logger.warning(f"Failed to reload history: {e}")
            
            self._access_times[conversation_id] = datetime.now(timezone.utc)
            return agent
        
        # 创建新 Agent
        from app.langchain.agents.supervisor_agent import SupervisorAgent
        
        agent = SupervisorAgent(
            provider=provider,
            model=model,
            conversation_id=conversation_id,
            db_session=db_session,
        )
        
        # 加载历史到共享 memory
        if history_enabled:
            try:
                loaded_count = await agent.load_history(db_session, limit=history_limit)
                logger.info(f"Loaded {loaded_count} history messages for {conversation_id}")
            except Exception as e:
                logger.warning(f"Failed to load history: {e}")
        
        self._active_agents[conversation_id] = agent
        self._access_times[conversation_id] = datetime.now(timezone.utc)
        
        return agent
```

---

## 四、删除冗余代码

### 4.1 可删除的文件

```
backend/app/langchain/services/rag/context_manager.py  # 整个文件可删除
```

### 4.2 需要修改的文件

| 文件 | 修改内容 |
|------|----------|
| `memory/short_term.py` | 添加 `get_history_as_turns()` 和 `get_context_summary()` 方法 |
| `agents/main_agent.py` | 支持外部注入 `short_term_memory` |
| `agents/rag_agent.py` | 使用外部 `short_term_memory`，删除 `ContextManager` |
| `agents/researcher_agent.py` | 新增 `short_term_memory` 参数，支持上下文感知搜索 |
| `agents/supervisor_agent.py` | 创建共享 memory，注入到所有子 Agent |
| `agents/agent_manager.py` | 使用 `shared_memory` 和 `load_history()` |

---

## 五、重构后的调用关系

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              重构后调用关系                                          │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  API 请求                                                                           │
│      │                                                                              │
│      ▼                                                                              │
│  AgentManager.get_agent(conversation_id)                                            │
│      │                                                                              │
│      ├── 创建 SupervisorAgent                                                       │
│      │       ├── 创建 shared_memory = ShortTermMemory()                            │
│      │       ├── 创建 MainAgent(short_term_memory=shared_memory)                   │
│      │       ├── 创建 RagAgent(short_term_memory=shared_memory)                    │
│      │       └── 创建 ResearcherAgent(short_term_memory=shared_memory)            │
│      │                                                                              │
│      └── agent.load_history(db_session)                                             │
│              └── 加载到 shared_memory                                               │
│                                                                                     │
│  SupervisorAgent.chat(message)                                                      │
│      │                                                                              │
│      ├── 意图分类 → "rag_first"                                                     │
│      │       └── RagAgent.process_query()                                           │
│      │               ├── history = shared_memory.get_history_as_turns()            │
│      │               └── query_rewriter.rewrite(query, history) ✅ 有数据          │
│      │                                                                              │
│      ├── 意图分类 → "research_first"                                                │
│      │       └── ResearcherAgent.research()                                         │
│      │               ├── context = shared_memory.get_context_summary()             │
│      │               └── 基于上下文生成精准搜索 ✅                                  │
│      │                                                                              │
│      └── 意图分类 → "direct"                                                        │
│              └── MainAgent.chat()                                                   │
│                      └── 使用 shared_memory ✅ 同一数据                             │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 六、测试验证

```python
# 测试脚本
async def test_shared_memory():
    # 1. 创建 Agent
    agent = await agent_manager.get_agent(
        conversation_id="test-123",
        db_session=db,
    )
    
    # 2. 验证所有 Agent 共享同一个 memory
    assert agent.main_agent.short_term_memory is agent.shared_memory
    assert agent.rag_agent._short_term_memory is agent.shared_memory
    assert agent.researcher_agent._short_term_memory is agent.shared_memory
    
    # 3. 添加消息
    agent.shared_memory.add_short_term_memory(HumanMessage(content="什么是 Python？"))
    agent.shared_memory.add_short_term_memory(AIMessage(content="Python 是一种编程语言。"))
    
    # 4. 验证 RagAgent 可以获取历史
    history = agent.rag_agent._short_term_memory.get_history_as_turns()
    assert len(history) == 2
    
    # 5. 验证 ResearcherAgent 可以获取上下文
    context = agent.researcher_agent._short_term_memory.get_context_summary()
    assert "Python" in context
    
    # 6. 验证查询重写
    result = await agent.rag_agent.process_query("它有什么特点？")
    # 应该能正确解析 "它" 指代 "Python"
    
    # 7. 验证研究助手
    result = await agent.researcher_agent.research("它的最新版本是什么？")
    # 应该能基于上下文理解 "它" 指代 "Python"
```

---

## 七、预期效果

| 功能 | 重构前 | 重构后 |
|------|--------|--------|
| **RAG 查询重写** | ❌ 无历史可用 | ✅ 可获取对话历史 |
| **ResearcherAgent 上下文** | ❌ 无上下文 | ✅ 可获取对话历史 |
| **代词解析** | ❌ 无法解析 | ✅ 正确解析代词 |
| **搜索精准度** | ❌ 缺乏上下文 | ✅ 基于历史精准搜索 |
| **代码冗余** | ❌ 两套记忆系统 | ✅ 统一记忆系统 |
| **数据一致性** | ❌ 数据不共享 | ✅ 数据共享 |
| **维护成本** | ❌ 高 | ✅ 低 |

---

## 八、场景示例

### 场景 1：RAG 路由

```
用户: 什么是 Python？
助手: Python 是一种编程语言...

用户: 它有什么特点？  ← 包含代词 "它"
      │
      ▼
意图分类: KB_QUERY → rag_first
      │
      ▼
RagAgent.process_query("它有什么特点？")
      │
      ├── history = shared_memory.get_history_as_turns()
      │   └── [{role: "user", content: "什么是 Python？"}, ...]
      │
      └── query_rewriter.rewrite("它有什么特点？", history)
          └── "Python 有什么特点？" ✅ 正确解析代词
```

### 场景 2：Research 路由

```
用户: 我想了解 DeepSeek 公司
助手: DeepSeek 是一家 AI 公司...

用户: 帮我搜索一下他们的最新产品  ← 包含代词 "他们"
      │
      ▼
意图分类: SEARCH_TASK → research_first
      │
      ▼
ResearcherAgent.research("帮我搜索一下他们的最新产品")
      │
      ├── context = shared_memory.get_context_summary()
      │   └── "用户: 我想了解 DeepSeek 公司\n助手: DeepSeek 是一家 AI 公司..."
      │
      └── 基于上下文理解 "他们" = "DeepSeek"
          └── 搜索 "DeepSeek 最新产品" ✅ 精准搜索
```

### 场景 3：并行路由

```
用户: 帮我查一下 Python 的最新版本，并搜索相关的教程
      │
      ▼
意图分类: AMBIGUOUS → parallel (rag_first + research_first)
      │
      ▼
并行执行:
      │
      ├── RagAgent.process_query("Python 的最新版本")
      │       └── 使用 shared_memory ✅
      │
      └── ResearcherAgent.research("Python 相关教程")
              └── 使用 shared_memory ✅
      
结果选择 → 返回最佳结果
```
